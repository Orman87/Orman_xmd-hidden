const {
    proto,
    delay,
    getContentType,
    areJidsSameUser,
    generateWAMessage
} = require('@whiskeysockets/baileys')
const fs = require('fs')
const axios = require('axios')
const moment = require('moment-timezone')
const util = require('util')
const Jimp = require('jimp')
const child_process = require('child_process')
const { sizeFormatter } = require('human-readable')

/* ================= BASIC UTILS ================= */

exports.unixTimestampSeconds = (date = new Date()) =>
    Math.floor(date.getTime() / 1000)

exports.sleep = async (ms) => new Promise(r => setTimeout(r, ms))

exports.runtime = (seconds) => {
    seconds = Number(seconds)
    const d = Math.floor(seconds / (3600 * 24))
    const h = Math.floor(seconds % (3600 * 24) / 3600)
    const m = Math.floor(seconds % 3600 / 60)
    const s = Math.floor(seconds % 60)
    return [
        d ? d + "d" : "",
        h ? h + "h" : "",
        m ? m + "m" : "",
        s ? s + "s" : ""
    ].join(" ")
}

exports.formatp = sizeFormatter({
    std: 'JEDEC',
    decimalPlaces: 2
})

exports.getRandom = (ext = '') =>
    `${Math.floor(Math.random() * 10000)}${ext}`

exports.isUrl = (url) =>
    /https?:\/\/.+/gi.test(url)

exports.fetchJson = async (url, options = {}) => {
    try {
        const res = await axios({
            method: 'GET',
            url,
            headers: { 'User-Agent': 'Mozilla/5.0' },
            ...options
        })
        return res.data
    } catch {
        return null
    }
}

exports.fetchBuffer = async (url) => {
    try {
        const res = await axios.get(url, {
            responseType: 'arraybuffer',
            headers: { 'User-Agent': 'Mozilla/5.0' }
        })
        return res.data
    } catch {
        return null
    }
}

{
  command: ['getpp', 'pp', 'profilepic', 'getprofile'],
  operate: async ({ bot, m, reply, quoted, Access }) => {
    if (!Access) return reply(global.mess.owner);

    // ðŸ“· React instantly
    await bot.sendMessage(m.chat, {
      react: { text: "ðŸ“·", key: m.key }
    });

    if (!quoted) {
      return reply('âŒ Reply to a user message to get their profile picture.');
    }

    const userId = quoted.sender;

    try {
      const ppUrl = await bot.profilePictureUrl(userId, 'image');

      await bot.sendMessage(
        m.chat,
        {
          image: { url: ppUrl },
          caption: `ðŸ–¼ï¸ *Profile Picture*\n\n@${userId.split('@')[0]}`,
          mentions: [userId]
        },
        { quoted: m }
      );

    } catch (err) {
      console.error('[GETPP ERROR]', err);

      await bot.sendMessage(
        m.chat,
        {
          image: {
            url: 'https://cdn.pixabay.com/photo/2015/10/05/22/37/blank-profile-picture-973460_960_720.png'
          },
          caption: 'âš ï¸ User has no profile picture or privacy is enabled.'
        },
        { quoted: m }
      );
    }
  }
}
/* ================= GROUP UTILS ================= */

exports.getGroupAdmins = (participants = []) =>
    participants.filter(v => v.admin).map(v => v.id)

/* ================= MESSAGE SERIALIZER (FIXED) ================= */

exports.smsg = (bot, m, store) => {
    if (!m) return m
    const M = proto.WebMessageInfo

    /* ---------- KEY INFO ---------- */
    if (m.key) {
        m.id = m.key.id
        m.chat = m.key.remoteJid
        m.fromMe = m.key.fromMe
        m.isGroup = m.chat.endsWith('@g.us')
        m.sender = bot.decodeJid(
            m.fromMe
                ? bot.user.id
                : m.participant || m.key.participant || m.chat
        )
        if (m.isGroup) m.participant = bot.decodeJid(m.key.participant)
    }

    /* ---------- UNWRAP EPHEMERAL ---------- */
    if (m.message?.ephemeralMessage) {
        m.message = m.message.ephemeralMessage.message
    }

    if (m.message) {
        m.mtype = getContentType(m.message)

        /* ---------- UNWRAP VIEW-ONCE ---------- */
        if (
            m.mtype === 'viewOnceMessage' ||
            m.mtype === 'viewOnceMessageV2' ||
            m.mtype === 'viewOnceMessageV2Extension'
        ) {
            const vo = m.message[m.mtype]?.message
            m.msg = vo ? vo[getContentType(vo)] : null
        } else {
            m.msg = m.message[m.mtype]
        }

        /* ---------- SAFE TEXT ---------- */
        m.text =
            m.msg?.text ||
            m.msg?.caption ||
            m.message?.conversation ||
            m.msg?.contentText ||
            m.msg?.selectedDisplayText ||
            m.msg?.title ||
            ""

        m.body = m.text

        /* ---------- QUOTED ---------- */
        const quoted = m.msg?.contextInfo?.quotedMessage
        if (quoted) {
            let qType = getContentType(quoted)
            let qMsg = quoted[qType]

            if (qMsg?.ephemeralMessage) {
                qMsg = qMsg.ephemeralMessage.message[getContentType(qMsg.ephemeralMessage.message)]
                qType = getContentType(qMsg)
            }

            m.quoted = {
                mtype: qType,
                id: m.msg.contextInfo.stanzaId,
                chat: m.msg.contextInfo.remoteJid || m.chat,
                sender: bot.decodeJid(m.msg.contextInfo.participant),
                fromMe: areJidsSameUser(
                    bot.user.id,
                    m.msg.contextInfo.participant
                ),
                text:
                    qMsg?.text ||
                    qMsg?.caption ||
                    qMsg?.conversation ||
                    "",
                message: qMsg
            }

            m.quoted.download = () =>
                bot.downloadMediaMessage(m.quoted.message)

            m.quoted.delete = () =>
                bot.sendMessage(m.quoted.chat, { delete: m.quoted.id })
        }
    }

    /* ---------- HELPERS ---------- */
    m.reply = (text, chatId = m.chat, options = {}) =>
        bot.sendMessage(chatId, { text }, { quoted: m, ...options })

    m.copyNForward = (jid = m.chat, force = false, opts = {}) =>
        bot.copyNForward(jid, m, force, opts)

    return m
}